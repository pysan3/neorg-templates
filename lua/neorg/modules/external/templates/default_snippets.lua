---@diagnostic disable
-- stylua: ignore start
local ls = require("luasnip")
local s = ls.snippet
local sn = ls.snippet_node
local isn = ls.indent_snippet_node
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node
local c = ls.choice_node
local d = ls.dynamic_node
local r = ls.restore_node
local events = require("luasnip.util.events")
local ai = require("luasnip.nodes.absolute_indexer")
local fmt = require("luasnip.extras.fmt").fmt
local rep = require("luasnip.extras").rep
local m = require("luasnip.extras").m
local lambda = require("luasnip.extras").l
local postfix = require("luasnip.extras.postfix").postfix
local neorg = require("neorg.core")
local utils, log = neorg.utils, neorg.log

local snippets, autosnippets = {}, {}
local e = function(trig, name, dscr, wordTrig, regTrig, docstring, docTrig, hidden, priority)
  local ret = { trig = trig, name = name, dscr = dscr }
  if wordTrig ~= nil then ret["wordTrig"] = wordTrig end
  if regTrig ~= nil then ret["regTrig"] = regTrig end
  if docstring ~= nil then ret["docstring"] = docstring end
  if docTrig ~= nil then ret["docTrig"] = docTrig end
  if hidden ~= nil then ret["hidden"] = hidden end
  if priority ~= nil then ret["priority"] = priority end
  return ret
end
-- stylua: ignore end
---@diagnostic enable

local M = {
    date_format = [[%Y-%m-%d]],
    date_format_tree = [[%Y/%m/%d]],
    time_format = [[%H:%M]],
    url_lookup = {
        ["www.youtube.com"] = "YouTube",
        ["youtu.be"] = "YouTube",
    },
    magic_keywords = {
        CURSOR = i(0),
        METADATA = t("Error processing {METADATA}. This should be at the first line of template file."),
    },
}

---Convert time object into string with specified format.
---@param delta_date integer # Shift x number of days from `str_or_date`. (-1 means yesterday)
---@param str_or_date string|integer # osdate object or string representing date with `YYYY-mm-dd`.
---@param date_format string? # date format. If nil, `M.date_format` will be used.
---@return string # string representing the date.
M.parse_date = function(delta_date, str_or_date, date_format)
    if date_format == nil then
        date_format = M.date_format
    end
    if type(str_or_date) ~= "string" then
        local result = os.date(date_format, str_or_date + 86400 * delta_date)
        assert(type(result) == "string", "Neorg Template: Something went wrong in `parse_date`. Please open an issue.")
        return result
    else
        local year, month, day = string.match(str_or_date, [[^(%d%d%d%d)-(%d%d)-(%d%d)$]])
        local result = os.date(date_format, os.time({ year = year, month = month, day = day }) + 86400 * delta_date)
        assert(type(result) == "string", "Neorg Template: Something went wrong in `parse_date`. Please open an issue.")
        return result
    end
end

---Return string of date relative to today.
---@param delta_date integer # Shift x number of days from `str_or_date`. (-1 means yesterday)
---@param date_format string? # date format. If nil, `M.date_format` will be used.
---@return string # string representing the date.
M.current_date = function(delta_date, date_format)
    return M.parse_date(delta_date, os.time(), date_format)
end

---Basename stem of current file. `fnamemodify(..., ":t:r")`
---@return string # stem of current file (foo/bar.txt -> bar).
M.file_title = function()
    return vim.fn.fnamemodify(vim.api.nvim_buf_get_name(0), ":t:r")
end

---Alias to `os.time` by specifying year, month, date as arguments. If any of fields are nil, returns today's time instead.
---@param year integer?
---@param month integer?
---@param day integer?
---@return integer # ostime object
M.make_time_object = function(year, month, day)
    if year == nil or month == nil or day == nil then
        return os.time()
    end
    return os.time({ year = year, month = month, day = day })
end

---@deprecated Use `make_time_object` instead.
---@param year integer?
---@param month integer?
---@param day integer?
---@return integer
M.ostime = function(year, month, day)
    log.warn("Neorg Template: DEPRECATED: `ostime` has been renamed to `make_time_object`.")
    return M.make_time_object(year, month, day)
end

---Extract date object from current file tree generated by journal module. (2000/04/01.norg -> os.time(2000, 4, 1))
---@return integer # ostime object
M.file_tree_date = function()
    local f_name = vim.api.nvim_buf_get_name(0)
    local grandparent = vim.fn.fnamemodify(f_name, ":p:h:h:h") or ""
    local date_path = vim.fn.fnamemodify(f_name:sub(grandparent:len() + 2):gsub([[\]], "/"), ":r") or ""
    local year, month, day = string.match(date_path, [[^(%d%d%d%d)/(%d%d)/(%d%d)$]])
    return M.make_time_object(year, month, day)
end

---Extract date object from current file name generated by journal module. (2000-04-01.norg -> os.time(2000, 4, 1))
---@return integer # ostime object
M.file_name_date = function()
    local year, month, day = string.match(M.file_title() or "", [[^(%d%d%d%d)-(%d%d)-(%d%d)$]])
    return M.make_time_object(year, month, day)
end

---Parse url and return service name based on domain
---@param link string # url in shape of http(s)://domain.name/xxx
---@return string # Name of service
M.link_type = function(link)
    local domain = string.gsub(link, [[http.://([^/]-)/.*]], "%1")
    vim.notify(string.format(
        [[
URL: %s
-> Domain: %s
-> Lookup: %s
  ]],
        link,
        domain,
        M.url_lookup[domain]
    ))
    return M.url_lookup[domain] or domain
end

M.default_keywords = {
    TITLE = f(M.file_title),
    TITLE_INPUT = function()
        return i(1, M.file_title())
    end,
    INSERT = function()
        return i(1)
    end,
    WEATHER = c(1, { t("Sunny "), t("Cloudy "), t("Rainy ") }),
    AUTHOR = f(utils.get_username),
    URL_TAG = fmt([[#{url_type} {{{url}}}]], {
        url = i(1, "url"),
        url_type = f(function(args, _)
            return M.link_type(args[1][1]):lower()
        end, { 1 }),
    }),
    YESTERDAY = function()
        return t(M.current_date(-1))
    end,
    TODAY = function()
        return t(M.current_date(0))
    end,
    TOMORROW = function()
        return t(M.current_date(1))
    end,
    -- When journal.strategy == "flat"
    YESTERDAY_OF_FILENAME = function()
        return t(M.parse_date(-1, M.file_name_date()))
    end,
    TODAY_OF_FILENAME = function()
        return t(M.parse_date(0, M.file_name_date()))
    end,
    TOMORROW_OF_FILENAME = function()
        return t(M.parse_date(1, M.file_name_date()))
    end,
    -- When journal.strategy == "nested"
    YESTERDAY_OF_FILETREE = function()
        return t(M.parse_date(-1, M.file_tree_date(), M.date_format_tree))
    end,
    TODAY_OF_FILETREE = function()
        return t(M.parse_date(0, M.file_tree_date(), M.date_format_tree))
    end,
    TOMORROW_OF_FILETREE = function()
        return t(M.parse_date(1, M.file_tree_date(), M.date_format_tree))
    end,
}

return M
